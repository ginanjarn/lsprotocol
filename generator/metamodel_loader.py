from dataclasses import fields, is_dataclass
from enum import Enum
from typing import get_origin, get_args, Union, Literal, ForwardRef
from types import NoneType

import metaModel_schema
from metaModel_schema import (
    MetaModel,
    BaseType,
    ReferenceType,
    ArrayType,
    MapType,
    AndType,
    OrType,
    TupleType,
    StructureLiteralType,
    StringLiteralType,
    IntegerLiteralType,
    BooleanLiteralType,
)

schema_type_map = {
    "base": BaseType,
    "reference": ReferenceType,
    "array": ArrayType,
    "map": MapType,
    "and": AndType,
    "or": OrType,
    "tuple": TupleType,
    "literal": StructureLiteralType,
    "stringLiteral": StringLiteralType,
    "integerLiteral": IntegerLiteralType,
    "booleanLiteral": BooleanLiteralType,
}


def construct_schema_type(data: dict) -> object:
    cls = schema_type_map[data["kind"]]
    return cls(**data)


def construct_dataclass(data: dict, typ: type) -> object:
    kwargs = dict()
    for field in fields(typ):
        value = data.get(field.name)
        kwargs[field.name] = construct_object(value, field.type)
    return typ(**kwargs)


def construct_object(data: dict, typ: type) -> object:
    # Atomic type
    if typ in {bool, int, float, str}:
        if type(data) != typ:
            raise TypeError(f"{typ} is required")
        return data

    if is_dataclass(typ):
        return construct_dataclass(data, typ)

    args = get_args(typ)
    origin = get_origin(typ)

    # Literal
    if origin == Literal:
        if data not in args:
            raise TypeError(f"{typ} is required")
        return data

    # List
    if origin == list:
        return [construct_object(d, args[0]) for d in data]

    # Union
    if origin == Union:
        if data is None:
            if None in args:
                return data
            # 'NoneType' is generated by 'Optional'
            elif NoneType in args:
                return data
            else:
                raise TypeError(f"{typ} is required")

        for arg in args:
            try:
                return construct_object(data, arg)
            except TypeError:
                pass
        raise TypeError(f"{typ} is required")

    # ForwardRef
    if isinstance(typ, ForwardRef):
        cls = get_forwardref_type(typ)
        return construct_object(data, cls)

    # Enum
    if issubclass(typ, Enum):
        return typ(data)

    try:
        return construct_schema_type(data)
    except KeyError:
        raise TypeError(f"{typ} is required")


def get_forwardref_type(typ: ForwardRef) -> type:
    ref = typ.__forward_arg__
    return getattr(metaModel_schema, ref)


def load_meta_model(metamodel: dict) -> MetaModel:
    return construct_object(metamodel, MetaModel)
